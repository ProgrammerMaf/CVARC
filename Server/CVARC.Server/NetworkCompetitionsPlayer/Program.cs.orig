using System;
using System.Collections.Generic;
using System.Linq;
using NetworkCompetitionsPlayer.Contracts;

namespace NetworkCompetitionsPlayer
{
    public static class Program
    {
        private static readonly JsonHttpClient Client = new JsonHttpClient();
        private static readonly Dictionary<string, PlayerClient> Players = new Dictionary<string, PlayerClient>();
        private const string LevelName = "Level2";
        
        private static PlayerClient GetPlayer(string name)
        {
            if (!Players.ContainsKey(name))
                Players[name] = Client.SendRequest<PlayerClient>(Urls.GetPlayer + "?name=" + name);
            return Players[name];
        }

        [STAThread]
        static void Main()
        {
<<<<<<< Updated upstream
            try
            {
                InitCompetition(helloPackage, competitionsName);
                Application.EnableVisualStyles();
                Application.SetCompatibleTextRenderingDefault(false);
                form = new TutorialForm(competitionsBundle.competitions);
                new Thread(() => competitionsBundle.competitions.ProcessParticipants(realTime, 60 * 1000, participants))
                {
                    IsBackground = true
                }.Start();
                Application.Run(form);
            }
            catch (Exception e)
=======
            var competitionsInfo = Client.SendRequest<CompetitionsInfoClient>(Urls.GetCompetitionsInfo);
            var unplayedMatchs = competitionsInfo.MatchResults.Where(x => !x.IsFinished()).ToArray();
            foreach (var unplayedMatch in unplayedMatchs)
>>>>>>> Stashed changes
            {
                var result = new MatchPlayer().Play(LevelName, GetPlayer(unplayedMatch.Player), GetPlayer(unplayedMatch.Player2));
                Client.SendRequest(Urls.SaveMatchResult, result);
            }
        }
    }
}
